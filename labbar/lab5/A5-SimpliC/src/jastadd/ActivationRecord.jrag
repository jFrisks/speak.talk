import java.util.*;

aspect ActivationRecord {
    public class ActivationRecord {
        //Local variables wiht name -> int (Name -> Value) (Boolean is converted to int)
        private HashMap<String, Integer> locals = new HashMap<>();

        void put(String name, int value){
            locals.put(name, value);
        }

        int get(String name){
            int value = locals.get(name);
            return value;
        }

        boolean contains(String name){
            return locals.containsKey(name);
        }
    }

    public class Utils {
        public static int boolToInt(boolean b) {
            return b ? 1 : 0;
        }
    }

    /* Invokes eval on main function.
     * Main cannot be predefined.
     * @throws if main method not found
     */
    public void Program.eval(){
        //lookup main
        IdDecl main = lookup("main");
        if(main.isUnknown())
            throw new RuntimeException("Main method not found");

        //if found, add function as frame.
        FunctionDecl mainMethodDecl = (FunctionDecl) main.getParent();

        //eval main method (TODO: Check so it returns correct type?)
        mainMethodDecl.eval(new ActivationRecord());
    }

    syn Deque Program.stack() = new ArrayDeque();
    inh Deque ASTNode.stack();
    eq Program.getChild().stack() = stack();

    public void Block.eval(ActivationRecord actrec) {
        for (Stmt stmt : getStmtList()) {
            stmt.eval(actrec);
        }
    }

    public void FunctionDecl.eval(ActivationRecord actrec) {
        stack().push(actrec);
        Block block = getBlock();
        block.eval(actrec);
    }

    public void Stmt.eval(ActivationRecord actrec) {throw new RuntimeException();}


    /* Assignment always put left variable (idDecl or IdUse) as the value of the right expression
    * overwrites already declared var val, or declares the var
    * @throws if IdDecl is already declared
    */
    public void Assignment.eval(ActivationRecord actrec) {
        //TODO: Crate IDDecl eval. Handle throws here?
        //getLeft().eval(actrec);
        Expr left = getLeft();
        String leftName;
        if(left instanceof IdDecl){
            leftName = ((IdDecl)left).getID();
        }else if(left instanceof IdUse){
            leftName = ((IdUse)left).getID();
        }else{
            leftName = "Unknownfbfdkgbr'sdC-";
        }

        int rightExpr = getRight().eval(actrec);
        //adding to local
        actrec.put(leftName, rightExpr);
    }


    //TODO: Code Smell! Better version is to define lambda-function together when defining predefined FunctionDecls. This adds code to one place
    public void FunctionCallStmt.eval(ActivationRecord actrec) {
        String functionName = ((FunctionCall)getExpr()).getIdUse().getID();
        if(functionName.equals("print")){
            System.out.println(((FunctionCall)getExpr()).getExpr(0).eval(actrec));
        }else if(functionName.equals("read")){
            System.err.println("Predfined read not implemented");
        }else{
            System.err.println("Method read not implemented");
        }

    }

    public void IdDeclStmt.eval(ActivationRecord actrec) {
        //TODO: IdDeclStmt
    }

    public void IfElse.eval(ActivationRecord actrec) {
        if (getIfExpr().eval(actrec) == 1) {
            getIf().eval(actrec);
        } else if (hasElse()) {
            getElse().eval(actrec);
        }
    }

    public void While.eval(ActivationRecord actrec) {
        while (getExpr().eval(actrec) == 1) {
            getBlock().eval(actrec);
        }
    }

    public void ReturnStmt.eval(ActivationRecord actrec) {
        //TODO: ReturnStmt
    }

    public int Expr.eval(ActivationRecord actrec) {
        //TODO: Expr
        return -1;
        
    }

    public int Neg.eval(ActivationRecord actrec) {
        return - getExpr().eval(actrec);
        
    }

    public int Less.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) < getRight().eval(actrec));
    }

    public int Greater.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) > getRight().eval(actrec));
    }

    public int LessEq.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) <= getRight().eval(actrec));
    }

    public int GreaterEq.eval(ActivationRecord actrec) {
       return Utils.boolToInt(getLeft().eval(actrec) >= getRight().eval(actrec));
    }

    public int Eq.eval(ActivationRecord actrec) {
       return Utils.boolToInt(getLeft().eval(actrec) == getRight().eval(actrec));
    }

    public int NotEq.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) != getRight().eval(actrec));
    }

    public int Mul.eval(ActivationRecord actrec) {
        int left = getLeft().eval(actrec);
        int right = getRight().eval(actrec);
        int result = left * right;
        return result;
    }

    public int Add.eval(ActivationRecord actrec) {
        int left = getLeft().eval(actrec);
        int right = getRight().eval(actrec);
        int result = left + right;
        return result;
    }

    public int Sub.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) - getRight().eval(actrec);
    }

    public int Div.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) / getRight().eval(actrec);
        
    }

    public int Mod.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) % getRight().eval(actrec);
        
    }

    public int FunctionCall.eval(ActivationRecord actrec) {
        //TODO: FunctionCall
        return -1;
        
    }

    public int Numeral.eval(ActivationRecord actrec) {
        return Integer.parseInt(getNUMERAL());
    }

    /* Gets the variable assigned value */
    public int IdUse.eval(ActivationRecord actrec) {
        String name = getID();
        if(!actrec.contains(name)){
            throw new NoSuchElementException("Variable " + name + " not assigned a value in block");
        }
        return actrec.get(name);
    }

    /* IdDecl should decalre if not declared, otherwise throw
    */
    public int IdDecl.eval(ActivationRecord actrec) {
        //Throw if IT IS already in actrec!
        if(actrec.contains(getID())){
            throw new RuntimeException("Variable already declared");
        }
        return -1;
    }
}