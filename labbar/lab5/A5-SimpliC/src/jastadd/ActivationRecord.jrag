import java.util.*;

aspect ActivationRecord {
    public class ActivationRecord {
        //Local variables wiht name -> int (Name -> Value) (Boolean is converted to int)
        private HashMap<String, Integer> locals = new HashMap<>();
        private boolean shouldReturn = false;
        //Default java behavior
        private int returnValue = 0;

        void put(String name, int value){
            locals.put(name, value);
        }

        int get(String name){
            int value = locals.get(name);
            return value;
        }

        boolean contains(String name){
            return locals.containsKey(name);
        }

        void setReturnValue(int i) {
            returnValue = i;
        }

        void setShouldReturn(boolean b) {
            shouldReturn = b;
        }

        boolean shouldReturn() {
            return shouldReturn;
        }

        int getReturnValue() {
            return returnValue;
        }
    }

    public class Utils {
        public static int boolToInt(boolean b) {
            return b ? 1 : 0;
        }
    }

    /* Invokes eval on main function.
     * Main cannot be predefined.
     * @throws if main method not found
     */
    public void Program.eval(){
        //lookup main
        IdDecl main = lookup("main");
        if(main.isUnknown())
            throw new RuntimeException("Main method not found");

        //if found, add function as frame.
        FunctionDecl mainMethodDecl = (FunctionDecl) main.getParent();

        //eval main method (TODO: Check so it returns correct type?)
        mainMethodDecl.eval(new ActivationRecord());
    }

    syn Deque Program.stack() = new ArrayDeque();
    inh Deque ASTNode.stack();
    eq Program.getChild().stack() = stack();

    public void Block.eval(ActivationRecord actrec) {
        for (Stmt stmt : getStmtList()) {
            if (actrec.shouldReturn()) {
                break;
            }
            stmt.eval(actrec);

        }
    }

    public void FunctionDecl.eval(ActivationRecord actrec) {
        stack().push(actrec);
        Block block = getBlock();
        block.eval(actrec);
        stack().pop();
    }

    public void Stmt.eval(ActivationRecord actrec) {throw new RuntimeException();}


    /* Assignment always put left variable (idDecl or IdUse) as the value of the right expression
    * overwrites already declared var val, or declares the var
    * @throws if IdDecl is already declared
    */
    public void Assignment.eval(ActivationRecord actrec) {
        Expr left = getLeft();

        String leftName;
        if(left instanceof IdDecl){
            left.eval(actrec);
            //TODO: leftName should be idDecl.unqiqueName()
            //Call unqueName with first stmt and the original variable name
            leftName = ((IdDecl)left).uniqueName(this, ((IdDecl)left).getID());
        }else if(left instanceof IdUse){
            IdDecl idDecl = ((IdUse)left).decl();
            leftName = idDecl.uniqueName(this, idDecl.getID());
        }else{
            throw new RuntimeException("Assignment on unknown variable");
        }

        int rightExpr = getRight().eval(actrec);
        //adding to local
        System.out.println("Left name: " + leftName);
        actrec.put(leftName, rightExpr);
    }


    //TODO: Code Smell! Better version is to define lambda-function together when defining predefined FunctionDecls. This adds code to one place
    public void FunctionCallStmt.eval(ActivationRecord actrec) {
        String functionName = ((FunctionCall)getExpr()).getIdUse().getID();
        if(functionName.equals("print")){
            System.out.println(((FunctionCall)getExpr()).getExpr(0).eval(actrec));
        }else if(functionName.equals("read")){
            System.err.println("Predfined read not implemented");
        }else{
            //eval on functionCall
            ((FunctionCall)getExpr()).eval(actrec);
        }

    }

    public void IdDeclStmt.eval(ActivationRecord actrec) {
        getIdDecl().eval(actrec);
    }

    public void IfElse.eval(ActivationRecord actrec) {
        if (getIfExpr().eval(actrec) == 1) {
            getIf().eval(actrec);
        } else if (hasElse()) {
            getElse().eval(actrec);
        }
    }

    public void While.eval(ActivationRecord actrec) {
        while (getExpr().eval(actrec) == 1) {
            getBlock().eval(actrec);
        }
    }

    public void ReturnStmt.eval(ActivationRecord actrec) {
        actrec.setReturnValue(getExpr().eval(actrec));
        actrec.setShouldReturn(true);
    }

    public int Expr.eval(ActivationRecord actrec) {
        throw new RuntimeException("Eval not implemented for expression " + getClass().getName());
    }

    public int Neg.eval(ActivationRecord actrec) {
        return - getExpr().eval(actrec);
        
    }

    public int Less.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) < getRight().eval(actrec));
    }

    public int Greater.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) > getRight().eval(actrec));
    }

    public int LessEq.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) <= getRight().eval(actrec));
    }

    public int GreaterEq.eval(ActivationRecord actrec) {
       return Utils.boolToInt(getLeft().eval(actrec) >= getRight().eval(actrec));
    }

    public int Eq.eval(ActivationRecord actrec) {
       return Utils.boolToInt(getLeft().eval(actrec) == getRight().eval(actrec));
    }

    public int NotEq.eval(ActivationRecord actrec) {
        return Utils.boolToInt(getLeft().eval(actrec) != getRight().eval(actrec));
    }

    public int Mul.eval(ActivationRecord actrec) {
        int left = getLeft().eval(actrec);
        int right = getRight().eval(actrec);
        int result = left * right;
        return result;
    }

    public int Add.eval(ActivationRecord actrec) {
        int left = getLeft().eval(actrec);
        int right = getRight().eval(actrec);
        int result = left + right;
        return result;
    }

    public int Sub.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) - getRight().eval(actrec);
    }

    public int Div.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) / getRight().eval(actrec);
        
    }

    public int Mod.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) % getRight().eval(actrec);
        
    }

    public int FunctionCall.eval(ActivationRecord actrec) {
        //Loop through params in functionDecl (this adds ne activationRecord) and assign to newly declared params
        FunctionDecl functionDecl = (FunctionDecl) getIdUse().decl().getParent();

        //Create new activation record and connect functionCalls argument (expr) with corresponding functionDeclParam
        ActivationRecord newActrec = new ActivationRecord();
        for(int i = 0; i < functionDecl.getNumParam(); i++){
            //TODO: handle if not same length
            IdDecl param = functionDecl.getParam(i);
            Expr argument = getExpr(i);
            String name = param.uniqueName(getParent(), param.getID());
            newActrec.put(name, argument.eval(actrec));
        }
        functionDecl.eval(newActrec);
        return newActrec.getReturnValue();
    }

    public int Numeral.eval(ActivationRecord actrec) {
        return Integer.parseInt(getNUMERAL());
    }

    /* Gets the variable assigned value */
    public int IdUse.eval(ActivationRecord actrec) {
        String name = decl().uniqueName(getParent(), getID());
        if(!actrec.contains(name)){
            throw new NoSuchElementException("Variable " + name + " not assigned a value in block");
        }
        return actrec.get(name);
    }

    /* IdDecl should decalre if not declared, otherwise throw
    */
    public int IdDecl.eval(ActivationRecord actrec) {
        //Throw if IT IS already in actrec!
        String name = uniqueName(getParent(), getID());
        if(actrec.contains(name)){
            throw new RuntimeException("Variable already declared");
        }
        return -1;
    }





    /* Handle Shadowing that returns spceial name for var. First call
    * i = variable name
    * 0_i = decalration i of statement 0
    * 1_1_0_i = declaration i in statement 0, in statement 1, in statement 1
    */
    syn String IdDecl.uniqueName(ASTNode stmtNode, String unfinishedUniqueName) {
        //TODO: Create attribute or smoething for parentStmt (No hardcoding here...)
        //basecase when reached the FunctionDecl instead of block
        ASTNode parentStmtNode = stmtNode.getParent().getParent().getParent();
        System.out.println("Called uniqueName with parent "+ parentStmtNode.getClass().getName());
        if(stmtNode instanceof FunctionDecl){
            System.out.println("FunctionDecl");
            //get index of functionDecls blocks stmt
            //String stmtIndex = stmtNode.getParent().getIndexOfChild(stmtNode) + "";
            //String uniqueName = stmtIndex + "_" + unfinishedUniqueName;
            return unfinishedUniqueName;
        }else{
            String stmtIndex = stmtNode.getParent().getIndexOfChild(stmtNode) + "";
            String combinedUniqueName = stmtIndex + "_" + unfinishedUniqueName;
            System.out.println(stmtIndex);
            System.out.println(combinedUniqueName);
            return uniqueName(parentStmtNode, combinedUniqueName);
        }


    }
}